package edu.usc.sql.graphs.cdg;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import edu.usc.sql.graphs.EdgeInterface;
import edu.usc.sql.graphs.NodeInterface;

public class PostDominator {
	private Set<NodeInterface> allNode;
	private Set<EdgeInterface> allEdge;
	private Set<DNode> allDNode = new HashSet<>();
	
	public PostDominator(Set<NodeInterface> allNode,Set<EdgeInterface> allEdge)
	{
		this.allNode = allNode;
		this.allEdge = allEdge;
	//	this.allNode=allNode;
		for(NodeInterface n:allNode)
		{	
			allDNode.add(new DNode(n));
		}
	}
	private void initialize()
	{
		for(DNode rn:allDNode)
		{
			if(rn.getNode().getOutEdges().isEmpty())
				rn.getDomSet().add(rn.getNode());
			else
			{
				for(NodeInterface n: allNode)
					rn.getDomSet().add(n);
			}
		}
	}
	private boolean compareTwoSet(Set<NodeInterface> oldset,Set<NodeInterface> newset)
	{
		if(oldset.containsAll(newset)&&newset.containsAll(oldset))
			return true;
		else 
			return false;
	}
	public boolean isPostDominate(NodeInterface source,NodeInterface dest)
	{
		for(DNode dn:allDNode)
		{
			if(dn.getNode().equals(dest))
				if(dn.getDomSet().contains(source))
					return true;
		}
		return false;
	}
	public void computePostDominator()
	{
		initialize();
		Map<DNode,ArrayList<DNode>> preList = new HashMap<>();
		//Create successor list for each node
		for(DNode node:allDNode)
		{
			ArrayList<DNode> nodePre = new ArrayList<> ();
			for(EdgeInterface e: node.getNode().getOutEdges())
			{
				for(DNode n:allDNode)
					if(n.getNode().equals(e.getDestination()))			
						nodePre.add(n);			
						
			}
			
			preList.put(node, nodePre);
			
		}
		boolean change = true;
		
		while(change)
		{
			change = false;
			for(DNode rn: allDNode)
			{
				//exclude the exit node
				if(!rn.getNode().getOutEdges().isEmpty())
				{
					Set<NodeInterface> temp = new HashSet<>();
					
					//initialize
					DNode first = preList.get(rn).get(0);
					for(NodeInterface n:first.getDomSet())
						temp.add(n);
					//intersect
					for(DNode d:preList.get(rn))
					{
						temp.retainAll(d.getDomSet());
					}
					//union itself
					if(!temp.contains(rn.getNode()))
						temp.add(rn.getNode());
										
					
					if(!compareTwoSet(rn.getDomSet(), temp))
					{
						change=true;
						rn.getDomSet().clear();
						for(NodeInterface n:temp)
						{
							rn.getDomSet().add(n);
						}
		
					}
				}
			}
		}
		
		for(DNode d:allDNode)
		{
			System.out.print(d.getNode().getName()+": ");
			for(NodeInterface n:d.getDomSet())
			{
				System.out.print(n.getName()+" ");
			}
			System.out.println("");
		}
	}
	
	public Set<DNode> getDNode()
	{
		return allDNode;
	}
}


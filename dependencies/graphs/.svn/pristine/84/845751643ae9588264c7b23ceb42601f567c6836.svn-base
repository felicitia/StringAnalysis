package edu.usc.sql.graphs.cdg;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import edu.usc.sql.graphs.EdgeInterface;
import edu.usc.sql.graphs.Graph;
import edu.usc.sql.graphs.Node;
import edu.usc.sql.graphs.NodeInterface;

//This class makes use of functions from PostDominator.java and builds the control dependancy table in a Map. The algorithm is built
//As per the procedure given in "Program Dependence Graph and its Use in Optimization"
public class CDG {
	
	protected static Map<NodeInterface,ArrayList<Node>> CDTable = new HashMap();
	protected static Map<NodeInterface,NodeInterface> SPairs = new HashMap();

	public CDG(Set<NodeInterface> allNode,Set<EdgeInterface> allEdge,NodeInterface entry)
	{
		//need to add the START node with edges to Entry and Exit
		
		
		//Creating the Post Dominator for the nodes and edges
		PostDominator PD = new PostDominator(allNode, allEdge, entry);
		
//		Graph cfg = new Graph();
//		
//		//Building the CFG
//		for (NodeInterface nodeInterface : allNode) {
//			cfg.addNode(nodeInterface);
//		}
		
		//Traversig through the edges of the CFG to figure out S
		//S= all node pairs which are not Post Dominant on each other
		
		for (EdgeInterface edgeInterface : allEdge) {
			if(!PD.isPostDominate(edgeInterface.getDestination(),edgeInterface.getSource()))
					{
						//If there is no Post Dominance i.e. B does not post Dominate A. Store it as SPair(Algo)
						
						System.out.println("Added:"+edgeInterface);
				
						SPairs.put(edgeInterface.getDestination(), edgeInterface.getSource());
						
			
					}
		}
		
		
		//Now that we have SPairs, let us calculate the LCM. The LCM is provided in the PostDominator class
		//getLeastCommonPostDominator()
		
		//Calculating the control Dependant of A out of the SPairs as per the Algo.
		for (Entry<NodeInterface, NodeInterface> SPairItr : SPairs.entrySet())
		{
		    System.out.println(SPairItr.getKey() + "/" + SPairItr.getValue());
		    
		    //Retrieving the LCM
		    NodeInterface LCM = PD.getLeastCommonPostDominator(SPairItr.getKey(), SPairItr.getValue());
		    
		    //Path from one node to the other node is obtained by the Post Dominance function: getPathBetweenTwoNodes()
		 
		    //Check if LCM = A or LCM is parent of A
		    if(LCM==SPairItr.getKey())
		    {
		    	//Traversing through the paths from LCM to B and adding all nodes to Control Dependant on A
		    	Set<NodeInterface> PathBet=PD.getPathBetweenTwoNodes(SPairItr.getValue(), LCM, true);
		    	
		    	ArrayList<Node> tempDep=null;
		    	
		    	for(NodeInterface NodeItr: PathBet)
		    	{
		    		tempDep.add((Node) NodeItr);
		    	}
		    	
		    	CDTable.put(SPairItr.getKey(), tempDep);
		    }
		    else //All nodes excluding A as LCM!=A
		    {
		    	//Traversing through the paths from LCM to B and adding all nodes to Control Dependant on A
		    	Set<NodeInterface> PathBet=PD.getPathBetweenTwoNodes(SPairItr.getValue(), LCM, false);
		    	
		    	ArrayList<Node> tempDep=null;
		    	
		    	for(NodeInterface NodeItr: PathBet)
		    	{
		    		tempDep.add((Node) NodeItr);
		    	}
		    	
		    	CDTable.put(SPairItr.getKey(), tempDep);
		    }
		    
		}
		
		
		
		
		
		
	}
	
	
	
	
}
